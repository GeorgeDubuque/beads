{"ast":null,"code":"import Shape from './shape';\nimport { HANDLE_POINT_CIRCLE_STYLE } from './config';\nconst KEYCODE_BACKSPACE = 8;\n\nclass Polygon extends Shape {\n  constructor(options) {\n    super(options);\n    this.temporaryPointsFollow = true;\n    this.isCreate = true;\n    this.pointsBackup = [];\n    this.borderPoints = [];\n    this.maxPointCount = options.maxPointCount || 50;\n    this.mouseInHandlePoint = false;\n\n    this._initPolygon();\n  }\n\n  _initPolygon() {\n    this.handlePointStyle = HANDLE_POINT_CIRCLE_STYLE;\n\n    this._initShape();\n\n    if (this.points.length > 0) {\n      this.isCreate = false;\n      this.temporaryPointsFollow = false;\n\n      this._draw();\n\n      this._backupData();\n    }\n  }\n\n  _draw() {\n    this.shape = this._drawPolygon();\n\n    this._generateHandlePointsByPoints();\n\n    this._generateBorderPoints();\n\n    if (this.edit) {\n      this._drawPolygonHandlePoints();\n    }\n  }\n  /**\n   * Generate handlepoints by polygon points\n   *\n   * @memberof Rect\n   */\n\n\n  _generateHandlePointsByPoints() {\n    const points = this.getZoomAndMove();\n    this.handlePoints = [];\n\n    for (let i = 0; i < points.length; i++) {\n      this.handlePoints[i] = {\n        obj: null,\n        point: points[i]\n      };\n    }\n  }\n\n  _generateBorderPoints() {\n    let left, right, top, bottom;\n    const points = this.getZoomAndMove();\n\n    for (let i = 0; i < points.length; i++) {\n      if (left) {\n        if (points[i][0] < left) {\n          left = points[i][0];\n        }\n      } else {\n        left = points[i][0];\n      }\n\n      if (right) {\n        if (points[i][0] > right) {\n          right = points[i][0];\n        }\n      } else {\n        right = points[i][0];\n      }\n\n      if (top) {\n        if (points[i][1] < top) {\n          top = points[i][1];\n        }\n      } else {\n        top = points[i][1];\n      }\n\n      if (bottom) {\n        if (points[i][1] > bottom) {\n          bottom = points[i][1];\n        }\n      } else {\n        bottom = points[i][1];\n      }\n    }\n\n    this.borderPoints = [[left, top], [right, top], [right, bottom], [left, bottom]];\n  }\n\n  _drawPolygon() {\n    const path = this.getPath();\n    const newPath = new Path2D(path);\n\n    this.freeDraw._updateCtxStyle(this.shapeStyle);\n\n    console.log(this.temporaryPointsFollow);\n\n    if (!this.temporaryPointsFollow) {\n      this.freeDraw.ctx.fill(newPath);\n    }\n\n    this.freeDraw.ctx.stroke(newPath);\n    return newPath;\n  }\n\n  _drawPolygonHandlePoints() {\n    for (let point of this.handlePoints) {\n      point.obj = this._drawCirclePoint(point.point[0], point.point[1], this.handlePointStyle.radius, {\n        lineWidth: this.handlePointStyle.lineWidth,\n        fillStyle: this.handlePointStyle.fillStyle,\n        strokeStyle: this.handlePointStyle.strokeStyle\n      });\n    }\n  }\n\n  _handleKeydown(event) {\n    if (this.points.length > 0 && event.keyCode === KEYCODE_BACKSPACE) {\n      this.points.pop();\n\n      this.freeDraw._refreshShapesInCanvas();\n    }\n  }\n\n  _polygonMouseDown(event) {\n    const x = event.offsetX,\n          y = event.offsetY;\n\n    if (this.clickedHandlePoint) {\n      this.temporaryPointsFollow = false;\n      this.temporaryPoints = [];\n      this.temporaryPointsWithoutZoomAndOffset = [];\n    } else {\n      if (this.isCreate && this.points.length < this.maxPointCount) {\n        this.points.push(this.removePointZoomAndMove([x, y]));\n        this.freeDraw.eventsCallBack(event, this.id, 'mouseEnterHandlePoint');\n\n        if (this.points.length < this.maxPointCount) {\n          this.temporaryPointsFollow = true;\n        } else {\n          this.temporaryPointsFollow = false;\n        }\n      }\n    }\n\n    this.freeDraw._refreshShapesInCanvas();\n  }\n\n  _handleMouseMove(event) {\n    const x = event.offsetX,\n          y = event.offsetY;\n\n    if (this.clickedHandlePoint) {\n      this.points[this.clickedHandlePointIndex] = this.removePointZoomAndMove([x, y]);\n    } else if (this.clickedShape) {\n      const points = [];\n\n      for (let point of this.points) {\n        points.push([Number((point[0] + (x - this.clickedShapePoint[0]) / this.freeDraw.zoomLevel).toFixed(this.freeDraw.fix)), Number((point[1] + (y - this.clickedShapePoint[1]) / this.freeDraw.zoomLevel).toFixed(this.freeDraw.fix))]);\n      }\n\n      this.clickedShapePoint = [x, y];\n      this.points = points;\n\n      if (this.freeDraw.eventsReceive.includes('drag')) {\n        this.freeDraw.eventsCallBack(event, this.id, 'drag');\n      }\n    } else {\n      if (this.temporaryPointsFollow) {\n        this.temporaryPoints = [this.removePointZoomAndMove([x, y])];\n        this.temporaryPointsWithoutZoomAndOffset = [[x, y]];\n      }\n    }\n\n    this.freeDraw._refreshShapesInCanvas();\n\n    if (this._pointInHandlePoints(x, y)) {\n      if (!this.mouseInHandlePoint) {\n        this.freeDraw.eventsCallBack(event, this.id, 'mouseEnterHandlePoint');\n        this.mouseInHandlePoint = true;\n      }\n    } else {\n      if (this.mouseInHandlePoint) {\n        this.freeDraw.eventsCallBack(event, this.id, 'mouseLeaveHandlePoint');\n      }\n\n      this.mouseInHandlePoint = false;\n    }\n  }\n\n  getZoomAndMove(withTemporaryPoints) {\n    const points = [];\n    let allPoints = this.points;\n\n    if (withTemporaryPoints) {\n      allPoints = allPoints.concat(this.temporaryPoints);\n    }\n\n    for (let i = 0; i < allPoints.length; i++) {\n      let x = Number(((allPoints[i][0] - this.freeDraw.transformCenter[0]) * this.freeDraw.zoomLevel + this.freeDraw.transformCenter[0]).toFixed(this.freeDraw.fix));\n      let y = Number(((allPoints[i][1] - this.freeDraw.transformCenter[1]) * this.freeDraw.zoomLevel + this.freeDraw.transformCenter[1]).toFixed(this.freeDraw.fix));\n\n      if (this.freeDraw.offsetLeft !== 0) {\n        x = Number((x + this.freeDraw.offsetLeft).toFixed(this.freeDraw.fix));\n      }\n\n      if (this.freeDraw.offsetTop !== 0) {\n        y = Number((y + this.freeDraw.offsetTop).toFixed(this.freeDraw.fix));\n      }\n\n      points.push([x, y]);\n    }\n\n    return points;\n  }\n\n  removePointZoomAndMove([x, y]) {\n    return [Number(((x - this.freeDraw.transformCenter[0] - this.freeDraw.offsetLeft) / this.freeDraw.zoomLevel + this.freeDraw.transformCenter[0]).toFixed(this.freeDraw.fix)), Number(((y - this.freeDraw.transformCenter[1] - this.freeDraw.offsetTop) / this.freeDraw.zoomLevel + this.freeDraw.transformCenter[1]).toFixed(this.freeDraw.fix))];\n  }\n\n  _backupData() {\n    this.pointsBackup = JSON.parse(JSON.stringify(this.points));\n  }\n\n  _rollbackData() {\n    this.points = JSON.parse(JSON.stringify(this.pointsBackup));\n  }\n\n  getPath() {\n    let path = 'M' + this.getZoomAndMove(this.edit === true).map(item => item.join(',')).join('L');\n\n    if (!this.temporaryPointsFollow) {\n      path += 'Z';\n    }\n\n    return path;\n  }\n\n  _toSVGPath() {\n    this.path = 'M' + this.points.map(item => {\n      const x = Number(item[0].toFixed(this.freeDraw.fix));\n      const y = Number(item[1].toFixed(this.freeDraw.fix));\n      return x + ',' + y;\n    }).join('L') + 'Z';\n    this.SVGPath = `<path d=\"${this.path}\" />`;\n  }\n\n  getBorderPoint(index) {\n    return this.borderPoints[index];\n  }\n\n}\n\nexport default Polygon;","map":{"version":3,"sources":["/home/george/projects/beads/beads/node_modules/free-draw/src/polygon.js"],"names":["Shape","HANDLE_POINT_CIRCLE_STYLE","KEYCODE_BACKSPACE","Polygon","constructor","options","temporaryPointsFollow","isCreate","pointsBackup","borderPoints","maxPointCount","mouseInHandlePoint","_initPolygon","handlePointStyle","_initShape","points","length","_draw","_backupData","shape","_drawPolygon","_generateHandlePointsByPoints","_generateBorderPoints","edit","_drawPolygonHandlePoints","getZoomAndMove","handlePoints","i","obj","point","left","right","top","bottom","path","getPath","newPath","Path2D","freeDraw","_updateCtxStyle","shapeStyle","console","log","ctx","fill","stroke","_drawCirclePoint","radius","lineWidth","fillStyle","strokeStyle","_handleKeydown","event","keyCode","pop","_refreshShapesInCanvas","_polygonMouseDown","x","offsetX","y","offsetY","clickedHandlePoint","temporaryPoints","temporaryPointsWithoutZoomAndOffset","push","removePointZoomAndMove","eventsCallBack","id","_handleMouseMove","clickedHandlePointIndex","clickedShape","Number","clickedShapePoint","zoomLevel","toFixed","fix","eventsReceive","includes","_pointInHandlePoints","withTemporaryPoints","allPoints","concat","transformCenter","offsetLeft","offsetTop","JSON","parse","stringify","_rollbackData","map","item","join","_toSVGPath","SVGPath","getBorderPoint","index"],"mappings":"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","sourcesContent":["import Shape from './shape'\nimport { HANDLE_POINT_CIRCLE_STYLE } from './config'\n\nconst KEYCODE_BACKSPACE = 8\n\nclass Polygon extends Shape {\n  constructor (options) {\n    super(options)\n\n    this.temporaryPointsFollow = true\n\n    this.isCreate = true\n\n    this.pointsBackup = []\n    this.borderPoints = []\n\n    this.maxPointCount = options.maxPointCount || 50\n\n    this.mouseInHandlePoint = false\n    this._initPolygon()\n  }\n\n  _initPolygon () {\n    this.handlePointStyle = HANDLE_POINT_CIRCLE_STYLE\n    this._initShape()\n    if (this.points.length > 0) {\n      this.isCreate = false\n      this.temporaryPointsFollow = false\n      this._draw()\n      this._backupData()\n    }\n  }\n\n  _draw () {\n    this.shape = this._drawPolygon()\n    this._generateHandlePointsByPoints()\n    this._generateBorderPoints()\n    if (this.edit) {\n      this._drawPolygonHandlePoints()\n    }\n  }\n\n  /**\n   * Generate handlepoints by polygon points\n   *\n   * @memberof Rect\n   */\n  _generateHandlePointsByPoints () {\n    const points = this.getZoomAndMove()\n    this.handlePoints = []\n    for (let i = 0; i < points.length; i++) {\n      this.handlePoints[i] = { obj: null, point: points[i] }\n    }\n  }\n\n  _generateBorderPoints () {\n    let left, right, top, bottom\n    const points = this.getZoomAndMove()\n    for (let i = 0; i < points.length; i++) {\n      if (left) {\n        if (points[i][0] < left) {\n          left = points[i][0]\n        }\n      } else {\n        left = points[i][0]\n      }\n      if (right) {\n        if (points[i][0] > right) {\n          right = points[i][0]\n        }\n      } else {\n        right = points[i][0]\n      }\n      if (top) {\n        if (points[i][1] < top) {\n          top = points[i][1]\n        }\n      } else {\n        top = points[i][1]\n      }\n      if (bottom) {\n        if (points[i][1] > bottom) {\n          bottom = points[i][1]\n        }\n      } else {\n        bottom = points[i][1]\n      }\n    }\n    this.borderPoints = [\n      [left, top],\n      [right, top],\n      [right, bottom],\n      [left, bottom]\n    ]\n  }\n\n  _drawPolygon () {\n    const path = this.getPath()\n    const newPath = new Path2D(path)\n    this.freeDraw._updateCtxStyle(this.shapeStyle)\n    console.log(this.temporaryPointsFollow)\n    if (!this.temporaryPointsFollow) {\n      this.freeDraw.ctx.fill(newPath)\n    }\n    this.freeDraw.ctx.stroke(newPath)\n    return newPath\n  }\n\n  _drawPolygonHandlePoints () {\n    for (let point of this.handlePoints) {\n      point.obj = this._drawCirclePoint(\n        point.point[0],\n        point.point[1],\n        this.handlePointStyle.radius,\n        {\n          lineWidth: this.handlePointStyle.lineWidth,\n          fillStyle: this.handlePointStyle.fillStyle,\n          strokeStyle: this.handlePointStyle.strokeStyle\n        }\n      )\n    }\n  }\n\n  _handleKeydown (event) {\n    if (this.points.length > 0 && event.keyCode === KEYCODE_BACKSPACE) {\n      this.points.pop()\n      this.freeDraw._refreshShapesInCanvas()\n    }\n  }\n\n  _polygonMouseDown (event) {\n    const { offsetX: x, offsetY: y } = event\n    if (this.clickedHandlePoint) {\n      this.temporaryPointsFollow = false\n      this.temporaryPoints = []\n      this.temporaryPointsWithoutZoomAndOffset = []\n    } else {\n      if (this.isCreate && this.points.length < this.maxPointCount) {\n        this.points.push(this.removePointZoomAndMove([x, y]))\n        this.freeDraw.eventsCallBack(event, this.id, 'mouseEnterHandlePoint')\n        if (this.points.length < this.maxPointCount) {\n          this.temporaryPointsFollow = true\n        } else {\n          this.temporaryPointsFollow = false\n        }\n      }\n    }\n    this.freeDraw._refreshShapesInCanvas()\n  }\n\n  _handleMouseMove (event) {\n    const { offsetX: x, offsetY: y } = event\n    if (this.clickedHandlePoint) {\n      this.points[this.clickedHandlePointIndex] = this.removePointZoomAndMove([x, y])\n    } else if (this.clickedShape) {\n      const points = []\n      for (let point of this.points) {\n        points.push([\n          Number((point[0] + (x - this.clickedShapePoint[0]) / this.freeDraw.zoomLevel).toFixed(this.freeDraw.fix)),\n          Number((point[1] + (y - this.clickedShapePoint[1]) / this.freeDraw.zoomLevel).toFixed(this.freeDraw.fix))\n        ])\n      }\n      this.clickedShapePoint = [x, y]\n      this.points = points\n      if (this.freeDraw.eventsReceive.includes('drag')) {\n        this.freeDraw.eventsCallBack(event, this.id, 'drag')\n      }\n    } else {\n      if (this.temporaryPointsFollow) {\n        this.temporaryPoints = [this.removePointZoomAndMove([x, y])]\n        this.temporaryPointsWithoutZoomAndOffset = [[x, y]]\n      }\n    }\n    this.freeDraw._refreshShapesInCanvas()\n    if (this._pointInHandlePoints(x, y)) {\n      if (!this.mouseInHandlePoint) {\n        this.freeDraw.eventsCallBack(event, this.id, 'mouseEnterHandlePoint')\n        this.mouseInHandlePoint = true\n      }\n    } else {\n      if (this.mouseInHandlePoint) {\n        this.freeDraw.eventsCallBack(event, this.id, 'mouseLeaveHandlePoint')\n      }\n      this.mouseInHandlePoint = false\n    }\n  }\n\n  getZoomAndMove (withTemporaryPoints) {\n    const points = []\n    let allPoints = this.points\n    if (withTemporaryPoints) {\n      allPoints = allPoints.concat(this.temporaryPoints)\n    }\n    for (let i = 0; i < allPoints.length; i++) {\n      let x = Number(((allPoints[i][0] - this.freeDraw.transformCenter[0]) * this.freeDraw.zoomLevel + this.freeDraw.transformCenter[0]).toFixed(this.freeDraw.fix))\n      let y = Number(((allPoints[i][1] - this.freeDraw.transformCenter[1]) * this.freeDraw.zoomLevel + this.freeDraw.transformCenter[1]).toFixed(this.freeDraw.fix))\n      if (this.freeDraw.offsetLeft !== 0) {\n        x = Number((x + this.freeDraw.offsetLeft).toFixed(this.freeDraw.fix))\n      }\n      if (this.freeDraw.offsetTop !== 0) {\n        y = Number((y + this.freeDraw.offsetTop).toFixed(this.freeDraw.fix))\n      }\n      points.push([x, y])\n    }\n    return points\n  }\n\n  removePointZoomAndMove ([x, y]) {\n    return [\n      Number((((x - this.freeDraw.transformCenter[0] - this.freeDraw.offsetLeft) / this.freeDraw.zoomLevel) + this.freeDraw.transformCenter[0]).toFixed(this.freeDraw.fix)),\n      Number((((y - this.freeDraw.transformCenter[1] - this.freeDraw.offsetTop) / this.freeDraw.zoomLevel) + this.freeDraw.transformCenter[1]).toFixed(this.freeDraw.fix))\n    ]\n  }\n\n  _backupData () {\n    this.pointsBackup = JSON.parse(JSON.stringify(this.points))\n  }\n\n  _rollbackData () {\n    this.points = JSON.parse(JSON.stringify(this.pointsBackup))\n  }\n\n  getPath () {\n    let path = 'M' + this.getZoomAndMove(this.edit === true).map(item => item.join(',')).join('L')\n    if (!this.temporaryPointsFollow) {\n      path += 'Z'\n    }\n    return path\n  }\n\n  _toSVGPath () {\n    this.path = 'M' + this.points.map(item => {\n      const x = Number(item[0].toFixed(this.freeDraw.fix))\n      const y = Number(item[1].toFixed(this.freeDraw.fix))\n      return x + ',' + y\n    }).join('L') + 'Z'\n    this.SVGPath = `<path d=\"${this.path}\" />`\n  }\n\n  getBorderPoint (index) {\n    return this.borderPoints[index]\n  }\n}\n\nexport default Polygon\n"]},"metadata":{},"sourceType":"module"}